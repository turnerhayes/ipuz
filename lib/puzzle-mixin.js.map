{"version":3,"sources":["../src/puzzle-mixin.js"],"names":["hashIt","require","get","set","size","PuzzleMixin","constructor","equalityTest","getter","setter","sizeOf","constructorName","name","findContainingClues","grid","width","height","rowIndex","columnIndex","containingClues","clueNumber","across","down","i","hasClueNumber","Object","defineProperties","prototype","equals","writable","configurable","value","other","clues","userSolution","info","extensions","hashCode","toString","Symbol","toStringTag","updateGrid","processGrid","updateCell","cell","enumerable","args","cellClueNumber","exports","module"],"mappings":"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","sourcesContent":["const hashIt = require(\"hash-it\");\nconst get    = require(\"lodash/get\");\nconst set    = require(\"lodash/set\");\nconst size   = require(\"lodash/size\");\n\n/**\n * Provides common functionality for {@link xpuz.ImmutablePuzzle} and {@link xpuz.Puzzle} classes.\n *\n * @mixin\n * @memberof xpuz\n *\n * @return {void}\n */\nfunction PuzzleMixin({ constructor, equalityTest, getter = get, setter = set, sizeOf = size }) {\n\tconst constructorName = constructor.name;\n\n\t/**\n\t * Finds which across and down clues a grid cell is a member of.\n\t *\n\t * @private\n\t *\n\t * @param {object} args - the function arguments\n\t * @param {Types.Grid|Types.ImmutableGrid} args.grid - the grid containing the cell\n\t * @param {number} args.width - the width of the grid (this is here just so that it doesn't have\n\t *\tto calculate it every time this is called)\n\t * @param {number} args.height - the height of the grid (this is here just so that it doesn't have\n\t *\tto calculate it every time this is called)\n\t * @param {number} args.rowIndex - the index of the row on which the cell occurs\n\t * @param {number} args.columnIndex - the index of the column on which the cell occurs\n\t *\n\t * @return {{across: ?number, down: ?number}} the clue numbers for the clues that contain this cell\n\t *\t(one or both of `across` and `down` keys may be populated)\n\t */\n\tfunction findContainingClues({ grid, width, height, rowIndex, columnIndex }) {\n\t\tconst containingClues = {};\n\n\t\tconst clueNumber = getter(grid, [rowIndex, columnIndex, \"clueNumber\"]);\n\n\t\tif (clueNumber !== undefined) {\n\t\t\t// This cell is a clue number cell--it defines either\n\t\t\t// its across clue number or its down clue number (or\n\t\t\t// both)\n\n\t\t\tif (\n\t\t\t\t// This is either at the left edge of the puzzle or\n\t\t\t\t// is bounded on the left by a block cell. This clue\n\t\t\t\t// number defines (at least) the cell's across clue number\n\t\t\t\t(columnIndex === 0 || getter(grid, [rowIndex, columnIndex - 1, \"isBlockCell\"])) &&\n\t\t\t\t// There is at least one fillable cell to the right\n\t\t\t\t(columnIndex < width - 1 && !getter(grid, [rowIndex, columnIndex + 1, \"isBlockCell\"]))\n\t\t\t) {\n\t\t\t\tcontainingClues.across = clueNumber;\n\t\t\t}\n\t\t\telse if (\n\t\t\t\t// There is at least one fillable cell below this\n\t\t\t\trowIndex < height - 1 && !getter(grid, [rowIndex + 1, columnIndex, \"isBlockCell\"])\n\t\t\t){\n\t\t\t\t// At least one cell exists to the left of this cell; this\n\t\t\t\t// is not an across clue number. It must be a down clue number.\n\t\t\t\tcontainingClues.down = clueNumber;\n\t\t\t}\n\t\t}\n\n\t\tif (!containingClues.across) {\n\t\t\t// Haven't found the across clue number yet.\n\t\t\t// Look to the left until we find a block cell or the edge of\n\t\t\t// the puzzle\n\t\t\tif (\n\t\t\t\t// At the left edge of the puzzle and there's a clue number\n\t\t\t\t(columnIndex === 0 && clueNumber !== undefined) &&\n\t\t\t\t// There is at least one fillable cell to the right\n\t\t\t\t!getter(grid, [rowIndex, columnIndex + 1, \"isBlockCell\"])\n\t\t\t) {\n\t\t\t\tcontainingClues.across = clueNumber;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (let i = columnIndex - 1; i >= 0; i--) {\n\t\t\t\t\tif (getter(grid, [rowIndex, i, \"isBlockCell\"])) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t// There is at least one fillable cell to the right\n\t\t\t\t\t\ti < width - 1 && !getter(grid, [rowIndex, i + 1, \"isBlockCell\"])\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontainingClues.across = getter(grid, [rowIndex, i, \"clueNumber\"]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!containingClues.down) {\n\t\t\t// Look at cells in other rows at the same index until we find a\n\t\t\t// cell with a clue number\n\t\t\tif (\n\t\t\t\t// At the top of the puzzle and there is a clue number\n\t\t\t\t(rowIndex === 0 && clueNumber !== undefined) &&\n\t\t\t\t// There is at least one fillable cell below it\n\t\t\t\t!getter(grid, [rowIndex + 1, columnIndex, \"isBlockCell\"])\n\t\t\t) {\n\t\t\t\tcontainingClues.down = clueNumber;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (let i = rowIndex; i >= 0; i--) {\n\t\t\t\t\tif (getter(grid, [i, columnIndex, \"isBlockCell\"])) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (\n\t\t\t\t\t\t// There is at least one fillable cell below it\n\t\t\t\t\t\ti < height - 1 && !getter(grid, [i + 1, columnIndex, \"isBlockCell\"])\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontainingClues.down = getter(grid, [i, columnIndex, \"clueNumber\"]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn containingClues;\n\t}\n\n\t/**\n\t * Determines whether a cell in the grid is at the start of a down or across clue (or\n\t * both), and thus should be given a clue number.\n\t *\n\t * @private\n\t *\n\t * @param {object} args - the function arguments\n\t * @param {Types.Grid|Types.ImmutableGrid} args.grid - the grid containing the cell\n\t * @param {number} args.width - the width of the grid (this is here just so that it doesn't have\n\t *\tto calculate it every time this is called)\n\t * @param {number} args.height - the height of the grid (this is here just so that it doesn't have\n\t *\tto calculate it every time this is called)\n\t * @param {number} args.rowIndex - the index of the row on which the cell occurs\n\t * @param {number} args.columnIndex - the index of the column on which the cell occurs\n\t *\n\t * @return {boolean} whether or not the specified cell should be given a clue number\n\t */\n\tfunction hasClueNumber({ grid, width, height, rowIndex, columnIndex }) {\n\t\tif (getter(grid, [rowIndex, columnIndex, \"isBlockCell\"])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (\n\t\t\t(columnIndex === 0 || getter(grid, [rowIndex, columnIndex - 1, \"isBlockCell\"])) &&\n\t\t\t(columnIndex + 1 < width && !getter(grid, [rowIndex, columnIndex + 1, \"isBlockCell\"]))\n\t\t) {\n\t\t\t// This cell is adjacent to the puzzle edge or a block cell on the left,\n\t\t\t// and has at least one input cell to its right--this cell starts an across clue\n\t\t\treturn true;\n\t\t}\n\n\t\tif (\n\t\t\t(rowIndex === 0 || getter(grid, [rowIndex - 1, columnIndex, \"isBlockCell\"])) &&\n\t\t\t(rowIndex + 1 < height && !getter(grid, [rowIndex + 1, columnIndex, \"isBlockCell\"]))\n\t\t) {\n\t\t\t// This cell is adjacent to the puzzle edge or a block cell on the top,\n\t\t\t// and has at least one input cell below it--this cell starts a down clue\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tObject.defineProperties(\n\t\tconstructor.prototype,\n\t\t{\n\t\t\t/**\n\t\t\t * Determines whether this object is equivalent to another object\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @param {*} other - the object to compare against\n\t\t\t *\n\t\t\t * @return {boolean} whether or not the other object is equal to this\n\t\t\t */\n\t\t\tequals: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function equals(other) {\n\t\t\t\t\tif (!(other instanceof constructor)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn equalityTest(this.grid, other.grid) &&\n\t\t\t\t\t\tequalityTest(this.clues, other.clues) &&\n\t\t\t\t\t\tequalityTest(this.userSolution, other.userSolution) &&\n\t\t\t\t\t\tequalityTest(this.info, other.info) &&\n\t\t\t\t\t\tequalityTest(this.extensions, other.extensions);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a hash code integer for this object.\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @return {number} the object's hash code\n\t\t\t */\n\t\t\thashCode: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function hashCode() {\n\t\t\t\t\treturn hashIt(this);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a string representation of this object.\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @return {string} string representation of this object\n\t\t\t */\n\t\t\ttoString: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function toString() {\n\t\t\t\t\treturn constructorName;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a string representation of this object.\n\t\t\t *\n\t\t\t * @member {string} @@toStringTag\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @return {string} string representation of this object\n\t\t\t */\n\t\t\t[Symbol.toStringTag]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget() {\n\t\t\t\t\treturn constructorName;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Updates the cells of the grid to have accurate clue numbering and `containingClues` properties.\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @param {Types.Grid|Types.ImmutableGrid} [grid=this.grid] - the grid to update and set as the puzzle's grid\n\t\t\t *\n\t\t\t * @return {Puzzle|ImmutablePuzzle} the puzzle, with the updated cell information (return type is whatever\n\t\t\t *\ttype `this` is)\n\t\t\t */\n\t\t\tupdateGrid: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function updateGrid(grid = this.grid) {\n\t\t\t\t\treturn setter(this, [\"grid\"], constructor.processGrid(grid));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the value of the specified cell and ensures that all cell information is kept up-to-date.\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @param {number} columnIndex - the column index of the cell to set\n\t\t\t * @param {number} rowIndex - the row index of the cell to set\n\t\t\t * @param {Types.GridCell|external:Immutable.Map<Types.GridCell>} - the cell information to set (this\n\t\t\t *\treplaces the existing cell information)\n\t\t\t *\n\t\t\t * @return {Puzzle|ImmutablePuzzle} the puzzle, with the updated cell information (return type is whatever\n\t\t\t *\ttype `this` is)\n\t\t\t */\n\t\t\tupdateCell: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function updateCell(columnIndex, rowIndex, cell) {\n\t\t\t\t\tconst grid = setter(this.grid, [rowIndex, columnIndex], cell);\n\n\t\t\t\t\treturn this.updateGrid(grid);\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t);\n\n\tObject.defineProperties(\n\t\tconstructor,\n\t\t{\n\t\t\t/**\n\t\t\t * Updates the specified grid with the correct cell information (clue numbers, etc.)\n\t\t\t *\n\t\t\t * @function\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @param {Types.Grid|Types.ImmutableGrid} grid - the\n\t\t\t *\tgrid to update\n\t\t\t *\n\t\t\t * @return {Puzzle|ImmutablePuzzle} the puzzle, with the updated cell information (return type is whatever\n\t\t\t *\ttype `grid` is)\n\t\t\t */\n\t\t\tprocessGrid: {\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: function processGrid(grid) {\n\t\t\t\t\tconst height = sizeOf(grid);\n\t\t\t\t\tconst width = sizeOf(getter(grid, [0]));\n\t\t\t\t\tlet clueNumber = 0;\n\n\t\t\t\t\tfor (let rowIndex = 0; rowIndex < height; rowIndex++) {\n\t\t\t\t\t\tfor (let columnIndex = 0; columnIndex < width; columnIndex++) {\n\t\t\t\t\t\t\tif (getter(grid, [rowIndex, columnIndex, \"isBlockCell\"])) {\n\t\t\t\t\t\t\t\tsetter(grid, [rowIndex, columnIndex, \"clueNumber\"], undefined);\n\t\t\t\t\t\t\t\tsetter(grid, [rowIndex, columnIndex, \"containingClues\"], undefined);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst args = {\n\t\t\t\t\t\t\t\tgrid,\n\t\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\t\theight,\n\t\t\t\t\t\t\t\trowIndex,\n\t\t\t\t\t\t\t\tcolumnIndex,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst cellClueNumber = hasClueNumber(args) ?\n\t\t\t\t\t\t\t\t++clueNumber :\n\t\t\t\t\t\t\t\tundefined;\n\n\t\t\t\t\t\t\tsetter(grid, [rowIndex, columnIndex, \"clueNumber\"], cellClueNumber);\n\n\t\t\t\t\t\t\tsetter(grid, [rowIndex, columnIndex, \"containingClues\"], findContainingClues(args));\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn grid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t);\n}\n\nexports = module.exports = PuzzleMixin;\n"],"file":"puzzle-mixin.js"}