{"version":3,"sources":["../../src/parsers/jpz.js"],"names":["isString","require","isObject","Promise","fs","readFile","promisify","Puzzle","_parsePuzzle","puzzle","resolve","reject","then","fileContent","toString","ex","Error","message","JPZParser","exports","module"],"mappings":";;;;;;AAAA;;;;;;AAOA,IAAMA,QAAQ,GAAUC,OAAO,CAAC,iBAAD,CAA/B;;AACA,IAAMC,QAAQ,GAAUD,OAAO,CAAC,iBAAD,CAA/B;;AACA,IAAME,OAAO,GAAWF,OAAO,CAAC,UAAD,CAA/B;;AACA,IAAMG,EAAE,GAAgBH,OAAO,CAAC,IAAD,CAA/B,C,CACA;;;AACA,IAAMI,QAAQ,GAAUD,EAAE,CAACC,QAAH,GAAcF,OAAO,CAACG,SAAR,CAAkBF,EAAE,CAACC,QAArB,CAAd,GAA+C,YAAM,CAAE,CAA/E;;AACA,IAAME,MAAM,GAAYN,OAAO,CAAC,WAAD,CAA/B;;AAGA,SAASO,YAAT,CAAsBC,MAAtB,EAA8B;AAC7B,SAAO,IAAIN,OAAJ,CACN,UAACO,OAAD,EAAUC,MAAV,EAAqB;AACpB,QAAIX,QAAQ,CAACS,MAAD,CAAZ,EAAsB;AACrB;AACA,aAAOJ,QAAQ,CAACI,MAAD,CAAR,CAAiBG,IAAjB,CACN,UAACC,WAAD;AAAA,eAAiBH,OAAO,CAAC,IAAIH,MAAJ,CAAWM,WAAW,CAACC,QAAZ,EAAX,CAAD,CAAxB;AAAA,OADM,WAGN,UAACC,EAAD,EAAQ;AACPJ,QAAAA,MAAM,CAAC,IAAIK,KAAJ,CAAU,yCAChBP,MADgB,GACP,IADO,GACAM,EAAE,CAACE,OADb,CAAD,CAAN;AAEA,OANK,CAAP;AAQA,KAVD,MAWK,IAAIf,QAAQ,CAACO,MAAD,CAAZ,EAAsB;AAC1B,aAAOC,OAAO,CAAC,IAAIH,MAAJ,CAAWE,MAAX,CAAD,CAAd;AACA,KAFI,MAGA;AACJ,aAAOE,MAAM,CAAC,IAAIK,KAAJ,CAAU,mDAAV,CAAD,CAAb;AACA;AACD,GAnBK,CAAP;AAqBA;AAED;;;;;IAGME,S;;;;;;;;;;AACL;;;;;;;;;0BASMT,M,EAAQ;AACb,aAAOD,YAAY,CAACC,MAAD,CAAnB;AACA;;;;;;AAGFU,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiBD,SAA3B","sourcesContent":["/**\n * JPZ Parser\n *\n * @description Parses .jpz formatted puzzles (NOT CURRENTLY IMPLEMENTED)\n * @module xpuz/parsers/jpz\n */\n\nconst isString        = require(\"lodash/isString\");\nconst isObject        = require(\"lodash/isObject\");\nconst Promise         = require(\"bluebird\");\nconst fs              = require(\"fs\");\n// fs is stubbed out for browser builds\nconst readFile        = fs.readFile ? Promise.promisify(fs.readFile) : () => {};\nconst Puzzle          = require(\"../puzzle\");\n\n\nfunction _parsePuzzle(puzzle) {\n\treturn new Promise(\n\t\t(resolve, reject) => {\n\t\t\tif (isString(puzzle)) {\n\t\t\t\t// path to puzzle\n\t\t\t\treturn readFile(puzzle).then(\n\t\t\t\t\t(fileContent) => resolve(new Puzzle(fileContent.toString()))\n\t\t\t\t).catch(\n\t\t\t\t\t(ex) => {\n\t\t\t\t\t\treject(new Error(\"Unable to read JPZ puzzle from file \" +\n\t\t\t\t\t\t\tpuzzle + \": \" + ex.message));\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if (isObject(puzzle)) {\n\t\t\t\treturn resolve(new Puzzle(puzzle));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn reject(new Error(\"parse() expects either a path string or an object\"));\n\t\t\t}\n\t\t}\n\t);\n}\n\n/**\n * JPZ parser class\n */\nclass JPZParser {\n\t/**\n\t * Parses a {@link module:xpuz/puzzle~Puzzle} from the input\n\t *\n\t * @param {string|object} puzzle - the source to parse the puzzle from; if a string,\n\t *\tit is assumed to be a file path, if an object, it defines a Puzzle object\n\t *\n\t * @return {external:Promise<module:xpuz/puzzle~Puzzle>} a promise that resolves with\n\t *\tthe parsed puzzle object\n\t */\n\tparse(puzzle) {\n\t\treturn _parsePuzzle(puzzle);\n\t}\n}\n\nexports = module.exports = JPZParser;\n"],"file":"jpz.js"}